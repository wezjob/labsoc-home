# ============================================
# LABSOC HOME - Zeek Pipeline
# ============================================

input {
  file {
    path => "/var/log/zeek/current/*.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb_zeek"
    type => "zeek"
  }
}

filter {
  if [type] == "zeek" {
    # Skip header lines
    if [message] =~ /^#/ {
      drop { }
    }

    # Detect log type from path
    grok {
      match => { "path" => "/var/log/zeek/current/%{WORD:zeek_log_type}\.log" }
    }

    # Add labsoc metadata
    mutate {
      add_field => {
        "labsoc.source" => "zeek"
        "labsoc.type" => "%{zeek_log_type}"
      }
    }

    # Parse conn.log
    if [zeek_log_type] == "conn" {
      csv {
        separator => "	"
        columns => ["ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p", 
                    "proto", "service", "duration", "orig_bytes", "resp_bytes", 
                    "conn_state", "local_orig", "local_resp", "missed_bytes", 
                    "history", "orig_pkts", "orig_ip_bytes", "resp_pkts", "resp_ip_bytes"]
      }
      
      mutate {
        rename => {
          "id.orig_h" => "[source][ip]"
          "id.orig_p" => "[source][port]"
          "id.resp_h" => "[destination][ip]"
          "id.resp_p" => "[destination][port]"
          "proto" => "[network][transport]"
        }
        add_field => {
          "[event][kind]" => "event"
          "[event][category]" => "network"
        }
      }
    }

    # Parse dns.log
    if [zeek_log_type] == "dns" {
      csv {
        separator => "	"
        columns => ["ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p",
                    "proto", "trans_id", "rtt", "query", "qclass", "qclass_name",
                    "qtype", "qtype_name", "rcode", "rcode_name", "AA", "TC", "RD",
                    "RA", "Z", "answers", "TTLs", "rejected"]
      }
      
      mutate {
        rename => {
          "id.orig_h" => "[source][ip]"
          "id.orig_p" => "[source][port]"
          "id.resp_h" => "[destination][ip]"
          "id.resp_p" => "[destination][port]"
          "query" => "[dns][question][name]"
          "qtype_name" => "[dns][question][type]"
          "answers" => "[dns][answers][data]"
        }
        add_field => {
          "[event][kind]" => "event"
          "[event][category]" => "network"
        }
      }
    }

    # Parse http.log
    if [zeek_log_type] == "http" {
      csv {
        separator => "	"
        columns => ["ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p",
                    "trans_depth", "method", "host", "uri", "referrer", "version",
                    "user_agent", "origin", "request_body_len", "response_body_len",
                    "status_code", "status_msg", "info_code", "info_msg", "tags",
                    "username", "password", "proxied", "orig_fuids", "orig_filenames",
                    "orig_mime_types", "resp_fuids", "resp_filenames", "resp_mime_types"]
      }
      
      mutate {
        rename => {
          "id.orig_h" => "[source][ip]"
          "id.orig_p" => "[source][port]"
          "id.resp_h" => "[destination][ip]"
          "id.resp_p" => "[destination][port]"
          "method" => "[http][request][method]"
          "uri" => "[url][path]"
          "host" => "[url][domain]"
          "user_agent" => "[user_agent][original]"
          "status_code" => "[http][response][status_code]"
        }
        add_field => {
          "[event][kind]" => "event"
          "[event][category]" => "web"
        }
      }
    }

    # Parse ssl.log
    if [zeek_log_type] == "ssl" {
      csv {
        separator => "	"
        columns => ["ts", "uid", "id.orig_h", "id.orig_p", "id.resp_h", "id.resp_p",
                    "version", "cipher", "curve", "server_name", "resumed", "last_alert",
                    "next_protocol", "established", "cert_chain_fuids", "client_cert_chain_fuids",
                    "subject", "issuer", "client_subject", "client_issuer", "validation_status"]
      }
      
      mutate {
        rename => {
          "id.orig_h" => "[source][ip]"
          "id.orig_p" => "[source][port]"
          "id.resp_h" => "[destination][ip]"
          "id.resp_p" => "[destination][port]"
          "server_name" => "[tls][server][name]"
          "version" => "[tls][version]"
          "cipher" => "[tls][cipher]"
        }
        add_field => {
          "[event][kind]" => "event"
          "[event][category]" => "network"
        }
      }
    }

    # Convert timestamp
    if [ts] {
      date {
        match => ["ts", "UNIX"]
        target => "@timestamp"
      }
    }

    # GeoIP enrichment
    if [source][ip] {
      geoip {
        source => "[source][ip]"
        target => "[source][geo]"
      }
    }

    if [destination][ip] {
      geoip {
        source => "[destination][ip]"
        target => "[destination][geo]"
      }
    }

    # Remove temporary fields
    mutate {
      remove_field => ["ts", "message", "path"]
    }
  }
}

output {
  if [type] == "zeek" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      user => "elastic"
      password => "${ELASTIC_PASSWORD}"
      index => "labsoc-zeek-%{[zeek_log_type]}-%{+YYYY.MM.dd}"
    }
  }
}
